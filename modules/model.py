


import pandas as pd
import numpy as np

from keras import Sequential
from keras.layers import Dense
from keras.callbacks import LambdaCallback

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

# Some parameters that we need to construct the layers of our model
OPTIMIZER = 'adam'
BATCH_SIZE = 30
EPOCHS = 150
INITIALIZER='normal'
LOSS = 'mean_squared_error'
ACTIVATION='relu'

class Model (object):

    def __init__(self, num_inputs):
        """Instantiates and adds layers to the Keras neural network model

        Parameters:
            num_inputs (int): amount of features that the model will train on
        """
        
        print('Constructing Model...')
        self.model = Sequential()
        
        # The Input Layer :
        self.model.add(Dense(16, kernel_initializer=INITIALIZER, input_dim = num_inputs, activation=ACTIVATION))

        # The Hidden Layers :
        self.model.add(Dense(32, kernel_initializer=INITIALIZER, activation=ACTIVATION))
        self.model.add(Dense(64, kernel_initializer=INITIALIZER, activation=ACTIVATION))
        self.model.add(Dense(128, kernel_initializer=INITIALIZER, activation=ACTIVATION))
        self.model.add(Dense(64, kernel_initializer=INITIALIZER, activation=ACTIVATION))
        self.model.add(Dense(32, kernel_initializer=INITIALIZER, activation=ACTIVATION))
        
        # The Output Layer :
        self.model.add(Dense(1, kernel_initializer=INITIALIZER, activation='linear'))

        self.model.compile(loss=LOSS, optimizer=OPTIMIZER)
        print(self.model.summary())

    
    def train(self, x, y, X_pred):
        """Splits the training data into training and test sets, then trains the model on the train set and
            calculates its root mean squared error using the test set
            
            Parameters:
                x (pd.DataFrame): the data generated by the preprocessor that the model will take as input
                
                y (pd.DataFrame): the outputs corresponding to the each row in "x" that the model should predict
                
                X_pred (pd.DataFrame): data that the model will use to predict (it should already be properly
                    formatted into a single row with 5 columns, in the same order as the original data)
            
            Returns:
                prediction_history (list): list of the predictions the model makes after each epoch of training
                
                rmse (float): the root mean squared error of the model when used to predict on the test set
        """
        
        X_train, X_test, Y_train, Y_test = train_test_split(x, y, test_size = 0.1, random_state = 52)
        
        prediction_history = []
        
        # At the end of each epoch of training, the model will predict on the real data we want it to predict for
        # (independent of the training and test sets) so that we can see how it improves over time
        callback = LambdaCallback(on_epoch_end=lambda epoch, logs: prediction_history.append(self.model.predict(X_pred).item(0)))
        
        self.model.fit(X_train, Y_train, epochs=EPOCHS, batch_size=BATCH_SIZE, verbose=1, callbacks=[callback])
        
        y_pred = self.model.predict(X_test)
        rmse = np.sqrt(mean_squared_error(Y_test, y_pred))
        
        print('*****')
        print('ROOT MEAN SQUARED ERROR: ' + str(rmse))
        print('*****')
        
        return prediction_history, rmse
    
    
    def predict(self, X_pred):
        """Model will predict on the data it is given and return the value of the prediction
            
            Parameters:
                X_pred (pd.DataFrame): data that the model will use to predict (it should already be properly
                    formatted into a single row with 5 columns, in the same order as the original data)
                
            Returns:
                closing price(float): the predicted price of the stock
        """
        
        Y_pred = self.model.predict(X_pred, verbose=1)
        
        closing_price = Y_pred.item(0)
        
        print('************************')
        print('')
        print('CLOSING PRICE PREDICTION: $' + str(closing_price))
        print('')
        print('************************')

        return closing_price
